[{"title":"Configuration","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/","content":"Configuration Basic OptionsLearn more about how to configure the SDK. These options are set when the SDK is first initialized, passed to the init function as an object.EnvironmentsLearn how to configure your SDK to tell Sentry about your environments.IntegrationsLearn more about how integrations extend the functionality of our SDK to cover common libraries and environments automatically.TransportsTransports let you change the way in which events are delivered to Sentry.Releases &amp; HealthLearn how to configure your SDK to tell Sentry about your releases.SamplingLearn how to configure the volume of error and transaction events sent to Sentry.FilteringLearn more about how to configure your SDK to filter events reported to Sentry.Shutdown and DrainingLearn more about the default behavior of our SDK if the game shuts down unexpectedly.","keywords":""},{"title":"Shutdown and Draining","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/draining","content":"Shutdown and Draining The default behavior of most SDKs is to send out events over the network asynchronously in the background. This means that some events might be lost if the application shuts down unexpectedly. The SDKs provide mechanisms to cope with this. The close method optionally takes a timeout in seconds and returns a promise that resolves when all pending events are flushed, or the timeout kicks in. Sentry.close(2):andThen(function() -- perform something after close end); After a call to close, the current client cannot be used anymore. It's important to only call close immediately before shutting down the application. Alternatively, the flush method drains the event queue while keeping the client enabled for continued use.","keywords":""},{"title":"Environments","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/environments","content":"Environments Environments tell you where an error occurred, whether that's in your production system, your staging server, or elsewhere. Sentry automatically creates an environment when it receives an event with the environment parameter set. Environments are case sensitive. The environment name can't contain newlines, spaces or forward slashes, can't be the string &quot;None&quot;, or exceed 64 characters. You can't delete environments, but you can hide them. Sentry.init({ environment = &quot;production&quot;, }) Environments help you better filter issues, releases, and user feedback in the Issue Details page of sentry.io, which you learn more about in the documentation that covers using environments.","keywords":""},{"title":"Integrations","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/integrations/","content":"Integrations Default IntegrationsLearn more about system integrations Dedupe, InboundFilters, GlobalHandlers, LinkedErrors, that are enabled by default to integrate into the standard library or the interpreter itself.Custom IntegrationsLearn how you can enable a custom integration.","keywords":""},{"title":"Custom Integrations","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/integrations/custom","content":"Custom Integrations Add a custom integration to your Lua using the following format: -- All integrations that come with an SDK can be found on Sentry.Integrations object -- Custom integration must conform to the Integration interface: https://github.com/Neura-Studios/sentry-lua/blob/78ee9d053dd572e2e34ebe6653161ac1fdf9b521/packages/types/src/_recursiveModules.lua#L989-L1000 Sentry.init({ -- ... integrations = {MyAwesomeIntegration.new()}, }); ","keywords":""},{"title":"Releases & Health","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/releases","content":"","keywords":""},{"title":"Bind the Version​","type":1,"pageTitle":"Releases & Health","url":"/sentry-lua/docs/configuration/releases#bind-the-version","content":"Include a release ID (often called a &quot;version&quot;) when you initialize the SDK. The release name cannot: contain newlines, tabulator characters, forward slashes(/) or back slashes(\\)be (in their entirety) period (.), double period (..), or space ( )exceed 200 characters The value can be arbitrary, but we recommend either of these naming strategies: Semantic Versioning: package@version or package@version+build (for example, my.project.name@2.3.12+1234) package is the unique identifier of the project/appversion is the semver-like structure &lt;major&gt;.&lt;minor?&gt;.&lt;patch?&gt;.&lt;revision?&gt;-&lt;prerelease?&gt;build is the number that identifies an iteration of your app Commit SHA: If you use a version control system like Git, we recommend using the identifying hash (for example, the commit SHA, da39a3ee5e6b4b0d3255bfef95601890afd80709). You can let Sentry CLI automatically determine this hash for supported version control systems. Learn more in the Sentry CLI documentation. Releases are global per organization; prefix them with something project-specific for easy differentiation. The behavior of a few features depends on whether a project is using semantic or time-based versioning. Regression detectionrelease:latest Sentry automatically detects whether a project is using semantic or time-based versioning based on: If ≤ 2 releases total: Sentry looks at most recent release.If 3-9 releases (inclusive): if any of the most recent 3 releases is semver, project is semver.If 10 or more releases: if any of the most recent 3 releases is semver, and 3 out of the most recent 10 releases is semver, then - the project is semver. "},{"title":"Setting a Release​","type":1,"pageTitle":"Releases & Health","url":"/sentry-lua/docs/configuration/releases#setting-a-release","content":"Sentry.init({ release = &quot;my-project-name@2.3.12&quot;, })  How you make the release name (or version) available to your code is up to you. For example, you could use a global _Gvariable that is set during the build process (using Darklua) or during initial start-up. Setting the release name tags each event with that release name. We recommend that you tell Sentry about a new release before sending events with that release name, as this will unlock a few more features. Learn more in theReleases documentation. If you don't tell Sentry about a new release, Sentry will automatically create a release entity in the system the first time it sees an event with that release ID. After configuring your SDK, you can install a repository integration or manually supply Sentry with your own commit metadata. Read the documentation about setting up releases for further information about integrations, associating commits, and telling Sentry when deploying releases. "},{"title":"Release Health​","type":1,"pageTitle":"Releases & Health","url":"/sentry-lua/docs/configuration/releases#release-health","content":"Monitor the health of releases by observing user adoption, usage of the application, percentage of crashes, and session data. Release health will provide insight into the impact of crashes and bugs as it relates to user experience, and reveal trends with each new issue through the Release Details graphs and filters. App hang detection are not available for Roblox. In order to monitor release health, the SDK sends session data. "},{"title":"Sessions​","type":1,"pageTitle":"Releases & Health","url":"/sentry-lua/docs/configuration/releases#sessions","content":"A session represents the interaction between the user and the application. Sessions contain a timestamp, a status (if the session was OK or if it crashed), and are always linked to a release. Most Sentry SDKs can manage sessions automatically. We mark the session as: crashed if an unhandled error or unhandled promise rejection bubbled up to the global handler.errored if the SDK captures an event that contains an exception (this includes manually captured errors). To receive data on user adoption, such as users crash free rate percentage, and the number of users that have adopted a specific release, set the user on the initialScope when initializing the SDK. By default, the Roblox SDKs are sending sessions. To disable sending sessions, set the autoSessionTracking flag tofalse: Sentry.init({ autoSessionTracking = false, -- default: true })  "},{"title":"GitHub Releases","type":0,"sectionRef":"#","url":"/sentry-lua/docs/installation-methods/github","content":"GitHub Releases If you can't use Wally to install the Sentry SDK, then you can manually install it from the GitHub releases. TODO: Document installation via GitHub releases","keywords":""},{"title":"Enriching Events","type":0,"sectionRef":"#","url":"/sentry-lua/docs/enriching-events/","content":"Enriching Events Add ContextCustom contexts allow you to attach arbitrary data (strings, lists, dictionaries) to an event.Identify UsersLearn how to configure the SDK to capture the user and gain critical pieces of information that construct a unique identity in Sentry.Set Transaction NameLearn how to set or override the transaction name to capture the user and gain critical pieces of information that construct a unique identity in Sentry.Customize TagsTags power UI features such as filters and tag-distribution maps. Tags also help you quickly access related events and view the tag distribution for a set of events.AttachmentsLearn more about how Sentry can store additional files in the same request as event attachments.BreadcrumbsLearn more about what Sentry uses to create a trail of events (breadcrumbs) that happened prior to an issue.User FeedbackLearn more about collecting user feedback when an event occurs. Sentry pairs the feedback with the original event, giving you additional insight into issues.Scopes and HubsSDKs will typically automatically manage the scopes for you in the framework integrations. Learn what a scope is and how you can use it to your advantage.Event ProcessorsLearn more about how you can add your own event processors globally or to the current scope.","keywords":""},{"title":"Default Integrations","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/integrations/default","content":"","keywords":""},{"title":"What's Enabled by Default​","type":1,"pageTitle":"Default Integrations","url":"/sentry-lua/docs/configuration/integrations/default#whats-enabled-by-default","content":""},{"title":"InboundFilters​","type":1,"pageTitle":"Default Integrations","url":"/sentry-lua/docs/configuration/integrations/default#inboundfilters","content":"Import name: Sentry.Integrations.InboundFilters This integration allows you to ignore specific errors based on the type, message, or URLs in a given exception. To configure this integration, use the ignoreErrors, ignoreTransactions, denyUrls, and allowUrls SDK options directly. Keep in mind that denyURLs and allowURLs only work for captured exceptions, not raw message events. "},{"title":"GlobalHandlers​","type":1,"pageTitle":"Default Integrations","url":"/sentry-lua/docs/configuration/integrations/default#globalhandlers","content":"Import name: Sentry.Integrations.GlobalHandlers This integration attaches global handlers to capture uncaught exceptions and unhandled rejections. Available options: { onerror = boolean onunhandledrejection = boolean }  "},{"title":"InApp​","type":1,"pageTitle":"Default Integrations","url":"/sentry-lua/docs/configuration/integrations/default#inapp","content":"Import name: Sentry.Integrations.InApp This integration marks stack frames from project dependencies as in_app = false, which allows Sentry to display stacktraces in a more useful way. By default, any frames whose lowercase filename starts with: replicatedstorage.packagesreplicatedfirst.packagespackages/dependencies/deps/ Will be marked as not in_app. The default configuration supports projects all projects, regardless of if they use stacktraces or not. "},{"title":"Dedupe​","type":1,"pageTitle":"Default Integrations","url":"/sentry-lua/docs/configuration/integrations/default#dedupe","content":"Import name: Sentry.Integrations.Dedupe This integration is enabled by default for Roblox, but only deduplicates certain events. It can be helpful if you're receiving many duplicate errors. Note, that Sentry only compares stack traces and fingerprints local Sentry = require(Path.To.Sentry) local DedupeIntegration = Sentry.Integrations.Dedupe Sentry.init({ dsn = &quot;__DSN__&quot;, integrations = {DedupeIntegration.new()} })  "},{"title":"Modifying System Integrations​","type":1,"pageTitle":"Default Integrations","url":"/sentry-lua/docs/configuration/integrations/default#modifying-system-integrations","content":"To disable system integrations, set defaultIntegrations = false when calling init(). To override their settings, provide a new instance with your config to the integrations option. For example, to turn off Roblox capturing global errors: Sentry.init({ dsn = &quot;__DSN__&quot;, integrations = { Sentry.Integrations.GlobalHandlers.new({ onerror = false, onunhandledrejection = false, }), }, })  "},{"title":"Removing an Integration​","type":1,"pageTitle":"Default Integrations","url":"/sentry-lua/docs/configuration/integrations/default#removing-an-integration","content":"This example removes the default-enabled integration for deduplicating events: local LuauPolyfill = require(Path.To.LuauPolyfill) local Array = LuauPolyfill.Array Sentry.init({ -- ... integrations = function(integrations) -- integrations will be all default integrations return Array.filter(integrations, function(integration) return integration.name ~= &quot;Dedupe&quot; end) end, })  "},{"title":"Installation Methods","type":0,"sectionRef":"#","url":"/sentry-lua/docs/installation-methods/","content":"Installation Methods WallyLearn about installing the SDK via Wally (recommended).GitHub ReleasesLearn about installing the SDK via GitHub releases.","keywords":""},{"title":"Wally","type":0,"sectionRef":"#","url":"/sentry-lua/docs/installation-methods/wally","content":"Wally To get started using the Sentry Roblox SDK, you need to install it. This can be done in several ways, but we recommendWally: # wally.toml [dependencies] Sentry = &quot;neura-studios/sentry-roblox@1.0.0&quot; wally install ","keywords":""},{"title":"Basic Options","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/options","content":"","keywords":""},{"title":"Common Options​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#common-options","content":"The list of common options across SDKs. These work more or less the same in all SDKs, but some subtle differences will exist to better support the platform. "},{"title":"dsn​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#dsn","content":"The DSN tells the Sentry SDK where to send events. If this value is not provided, the SDK will not send events. Learn more about DSN utilization. "},{"title":"debug​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#debug","content":"Turns debug mode on or off. If debug is enabled SDK will attempt to print out useful debugging information if something goes wrong with sending the event. The default is always false. It's generally not recommended to turn it on in production, though turning debug mode on will not cause any safety concerns. "},{"title":"release​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#release","content":"Sets the release. Some SDKs will try to automatically configure a release out of the box, but it's a better idea to manually set it to guarantee that the release is in sync with your deploy integrations. Release names are strings, but some formats are detected by Sentry and might be rendered differently. Learn more about how to send release data so Sentry can tell you about regressions between releases and identify the potential source inthe releases documentationor the sandbox. By default the SDK will try to read this value from the SENTRY_RELEASE global variable (in the Roblox SDK, this will be read off of the _G_.__SENTRY_RELEASE__ if available). "},{"title":"environment​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#environment","content":"Sets the environment. This string is freeform and not set by default. A release can be associated with more than one environment to separate them in the UI (think staging vs prod or similar). "},{"title":"sampleRate​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#samplerate","content":"Configures the sample rate for error events, in the range of 0.0 to 1.0. The default is 1.0 which means that 100% of error events are sent. If set to 0.1 only 10% of error events will be sent. Events are picked randomly. "},{"title":"maxBreadcrumbs​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#maxbreadcrumbs","content":"This variable controls the total amount of breadcrumbs that should be captured. This defaults to 100, but you can set this to any number. However, you should be aware that Sentry has a maximum payload size and any events exceeding that payload size will be dropped. "},{"title":"attachStacktrace​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#attachstacktrace","content":"When enabled, stack traces are automatically attached to all messages logged. Stack traces are always attached to exceptions; however, when this option is set, stack traces are also sent with messages. This option, for instance, means that stack traces appear next to all log messages. This option is off by default. Grouping in Sentry is different for events with stack traces and without. As a result, you will get new groups as you enable or disable this flag for certain events. "},{"title":"ignoreErrors​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#ignoreerrors","content":"A list of strings or regex patterns that match error messages that shouldn't be sent to Sentry. Messages that match these strings or regular expressions will be filtered out before they're sent to Sentry. When using strings, partial matches will be filtered out, so if you need to filter by exact match, use regex patterns instead. By default, all errors are sent. "},{"title":"ignoreTransactions​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#ignoretransactions","content":"A list of strings or regex patterns that match transaction names that shouldn't be sent to Sentry. Transactions that match these strings or regular expressions will be filtered out before they're sent to Sentry. When using strings, partial matches will be filtered out, so if you need to filter by exact match, use regex patterns instead. By default, all transactions are sent. "},{"title":"denyUrls​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#denyurls","content":"A list of strings or regex patterns that match error URLs that should not be sent to Sentry. Errors whose entire file URL contains (string) or matches (regex) at least one entry in the list will not be sent. As a result, if you add'foo.com' to the list, it will also match on https://bar.com/myfile/foo.com. By default, all errors are sent. "},{"title":"autoSessionTracking​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#autosessiontracking","content":"When set to true, the SDK will send session events to Sentry. This doesn't have much application in the Roblox SDK. "},{"title":"initialScope​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#initialscope","content":"Data to be set to the initial scope. Initial scope can be defined either as an object or a callback function, as shown below. Object: Sentry.init({ dsn = &quot;__DSN__&quot;, debug = true, initialScope = { tags = { myTag = &quot;my value&quot;, }, user = { id = &quot;42&quot;, username = &quot;johndoe&quot; }, }, })  Callback function: Sentry.init({ dsn = &quot;__DSN__&quot;, debug = true, initialScope = function(scope) scope:setTags({ a = &quot;b&quot; }); return scope; end, })  "},{"title":"maxValueLength​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#maxvaluelength","content":"Maximum number of characters a single value can have before it will be truncated (defaults to 250). "},{"title":"normalizeDepth​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#normalizedepth","content":"Sentry SDKs normalize any contextual data to a given depth. Any data beyond this depth will be trimmed and marked using its type instead ([Object] or [Array]), without walking the tree any further. By default, walking is performed three levels deep. "},{"title":"normalizeMaxBreadth​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#normalizemaxbreadth","content":"This is the maximum number of properties or entries that will be included in any given object or array when the SDK is normalizing contextual data. Any data beyond this depth will be dropped. (defaults to 1000) "},{"title":"enabled​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#enabled","content":"Specifies whether this SDK should send events to Sentry. Defaults to true. Setting this to enabled = false doesn't prevent all overhead from Sentry instrumentation. To disable Sentry completely, depending on environment, callSentry.init conditionally. "},{"title":"sendClientReports​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#sendclientreports","content":"Set this boolean to false to disable sending of client reports. Client reports are a protocol feature that let clients send status reports about themselves to Sentry. They are currently mainly used to emit outcomes for events that were never sent. "},{"title":"Integration Configuration​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#integration-configuration","content":"For many platform SDKs, integrations can be configured alongside it. On some platforms that happens as part of theinit() call, in some others, different patterns apply. "},{"title":"integrations​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#integrations","content":"In some SDKs, the integrations are configured through this parameter on library initialization. For more information, please see the documentation for a specific integration. "},{"title":"defaultIntegrations​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#defaultintegrations","content":"This can be used to disable integrations that are added by default. When set to false, no default integrations are added. "},{"title":"Hooks​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#hooks","content":"These options can be used to hook the SDK in various ways to customize the reporting of events. "},{"title":"beforeSend​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#beforesend","content":"This function is called with an SDK-specific message or error event object, and can return a modified event object, ornil to skip reporting the event. This can be used, for instance, for manual PII stripping before sending. "},{"title":"beforeSendTransaction​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#beforesendtransaction","content":"This function is called with an SDK-specific transaction event object, and can return a modified transaction event object, or nil to skip reporting the event. One way this might be used is for manual PII stripping before sending. "},{"title":"beforeBreadcrumb​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#beforebreadcrumb","content":"This function is called with an SDK-specific breadcrumb object before the breadcrumb is added to the scope. When nothing is returned from the function, the breadcrumb is dropped. To pass the breadcrumb through, return the first argument, which contains the breadcrumb object. The callback typically gets a second argument (called a &quot;hint&quot;) which contains the original object from which the breadcrumb was created to further customize what the breadcrumb should look like. "},{"title":"Transport Options​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#transport-options","content":"Transports are used to send events to Sentry. Transports can be customized to some degree to better support highly specific deployments. "},{"title":"transport​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#transport","content":"Switches out the transport used to send events. How this works depends on the SDK. It can, for instance, be used to capture events for unit-testing or to send it through some more complex setup that requires proxy authentication. "},{"title":"transportOptions​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#transportoptions","content":"Options used to configure the transport. This is an object with the following possible optional keys: headers: An object containing headers to be sent with every request. Used by the SDK's Roblox HttpServicetransport. "},{"title":"Tracing Options​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#tracing-options","content":""},{"title":"enableTracing​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#enabletracing","content":"A boolean value, if true, transactions and trace data will be generated and captured. This will set thetracesSampleRate to the recommended default of 1.0 if tracesSampleRate is not defined. Note thattracesSampleRate and tracesSampler take precedence over this option. "},{"title":"tracesSampleRate​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#tracessamplerate","content":"A number between 0 and 1, controlling the percentage chance a given transaction will be sent to Sentry. (0 represents 0% while 1 represents 100%.) Applies equally to all transactions created in the app. Either this ortracesSampler must be defined to enable tracing. "},{"title":"tracesSampler​","type":1,"pageTitle":"Basic Options","url":"/sentry-lua/docs/configuration/options#tracessampler","content":"A function responsible for determining the percentage chance a given transaction will be sent to Sentry. It will automatically be passed information about the transaction and the context in which it's being created, and must return a number between 0 (0% chance of being sent) and 1 (100% chance of being sent). Can also be used for filtering transactions, by returning 0 for those that are unwanted. Either this or tracesSampleRate must be defined to enable tracing. "},{"title":"Transports","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/transports","content":"","keywords":""},{"title":"HttpServiceTransport​","type":1,"pageTitle":"Transports","url":"/sentry-lua/docs/configuration/transports#httpservicetransport","content":"This transport is enabled by default for Roblox, and likely will not need to be changed. It exposes some basic configuration: type RobloxTransportOptions = { --- Custom headers for the transport. headers: Map&lt;string, string&gt;?, }  "},{"title":"Troubleshooting Source Maps","type":0,"sectionRef":"#","url":"/sentry-lua/docs/sourcemaps/troubleshooting","content":"","keywords":""},{"title":"Rojo project cannot build without an existing Sourcemap file​","type":1,"pageTitle":"Troubleshooting Source Maps","url":"/sentry-lua/docs/sourcemaps/troubleshooting#rojo-project-cannot-build-without-an-existing-sourcemap-file","content":"In the sourcemap guide, you're instructed to add a sourcemap.json file to to your Rojo project file. This causes an issue, because Rojo cannot build your project or the sourcemap unless a sourcemap.json file already exists. The error might look like this: [ERROR rojo] Rojo project referred to a file using $path that could not be turned into a Roblox Instance by Rojo. Check that the file exists and is a file type known by Rojo. Project path: {PROJECT_PATH}/example.project.json File $path: sourcemap.json  The solution to this problem is to create an empty sourcemap.json file before you build the real sourcemap. Here's the commands we use: echo &quot;{}&quot; &gt; sourcemap.json rojo sourcemap --output sourcemap.json example.project.json  Once you've generated the real sourcemap file, you can build your Rojo project as normal. "},{"title":"Distributed Tracing","type":0,"sectionRef":"#","url":"/sentry-lua/docs/usage/distributed-tracing","content":"","keywords":""},{"title":"What is Distributed Tracing?​","type":1,"pageTitle":"Distributed Tracing","url":"/sentry-lua/docs/usage/distributed-tracing#what-is-distributed-tracing","content":"In the context of tracing events across a distributed system, distributed tracing acts as a powerful debugging tool. Imagine your application as a vast network of interconnected parts. For example, your system might be spread across different servers or your application might split into different backend and frontend services, each potentially having their own technology stack. When an error or performance issue occurs, it can be challenging to pinpoint the root cause due to the complexity of such a system. Distributed tracing helps you follow the path of an event as it travels through this intricate web, recording every step it takes. By examining these traces, you can reconstruct the sequence of events leading up to the event of interest, identify the specific components involved, and understand their interactions. This detailed visibility enables you to diagnose and resolve issues more effectively, ultimately improving the reliability and performance of your distributed system. "},{"title":"Basic Example​","type":1,"pageTitle":"Distributed Tracing","url":"/sentry-lua/docs/usage/distributed-tracing#basic-example","content":"Here's an example showing a distributed trace in Sentry:  This distributed trace shows a Vue app's pageload making a request to a Python backend, which then calls the /apiendpoint of a Ruby microservice. What happens in the background is that Sentry uses reads and further propagates two HTTP headers between your applications: sentry-tracebaggage If you run any Lua applications (like your Roblox game!) in your distributed system, make sure that those two headers won't be blocked or stripped by your proxy servers, gateways, or firewalls. "},{"title":"How to Use Distributed Tracing?​","type":1,"pageTitle":"Distributed Tracing","url":"/sentry-lua/docs/usage/distributed-tracing#how-to-use-distributed-tracing","content":"TODO: Distributed tracing is not currently implemented in the Lua SDK. "},{"title":"Filtering","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/filtering","content":"","keywords":""},{"title":"Filtering Error Events​","type":1,"pageTitle":"Filtering","url":"/sentry-lua/docs/configuration/filtering#filtering-error-events","content":"Configure your SDK to filter error events by using the beforeSend callback method and configuring, enabling, or disabling integrations. "},{"title":"Using beforeSend​","type":1,"pageTitle":"Filtering","url":"/sentry-lua/docs/configuration/filtering#using-beforesend","content":"All Sentry SDKs support the beforeSend callback method. beforeSend is called immediately before the event is sent to the server, so it’s the final place where you can edit its data. It receives the event object as a parameter, so you can use that to modify the event’s data or drop it completely (by returning nil) based on custom logic and the data available on the event. In Lua, you can use a function to modify the event or return a completely new one. You can either return nil or an event payload. If you return nil, the event will be discarded. Sentry.init({ dsn = &quot;__DSN__&quot;, -- Called for message and error events beforeSend = function(event) -- Modify or drop the event here if event.user then -- Don't send user's email address event.user.email = nil end return event end, })  Note also that breadcrumbs can be filtered, as discussed in theBreadcrumbs documentation. Event Hints​ The beforeSend callback is passed both the event and a second argument, hint, that holds one or more hints. Typically a hint holds the original exception so that additional data can be extracted or grouping is affected. In this example, the fingerprint is forced to a common value if an exception of a certain type has been caught: Sentry.init({ -- ... beforeSend = function(event, hint) local error = hint.originalException local message = error and error.message if string.match(message, &quot;database unavailable&quot;) then event.fingerprint = { &quot;database-unavailable&quot; } end return event end, })  For information about which hints are available see hints in Lua. When the SDK creates an event or breadcrumb for transmission, that transmission is typically created from some sort of source object. For instance, an error event is typically created from a log record or exception instance. For better customization, SDKs send these objects to certain callbacks (beforeSend, beforeBreadcrumb or the event processor system in the SDK). "},{"title":"Using Hints​","type":1,"pageTitle":"Filtering","url":"/sentry-lua/docs/configuration/filtering#using-hints","content":"Hints are available in two places: beforeSend / beforeBreadcrumbeventProcessors Event and breadcrumb hints are objects containing various information used to put together an event or a breadcrumb. Typically hints hold the original exception so that additional data can be extracted or grouping can be affected. For events, hints contain properties such as event_id, originalException, syntheticException (used internally to generate cleaner stack trace), and any other arbitrary data that you attach. For breadcrumbs, the use of hints is implementation dependent. Hints for Events​ originalException The original exception that caused the Sentry SDK to create the event. This is useful for changing how the Sentry SDK groups events or to extract additional information. syntheticException When a string or a non-error object is raised, Sentry creates a synthetic exception so you can get a basic stack trace. This exception is stored here for further data extraction. Hints for Breadcrumbs​ event For breadcrumbs created from engine events, the Sentry SDK often supplies the event to the breadcrumb as a hint. level / input For breadcrumbs created from console log interceptions. This holds the original console log level and the original input data to the log function. "},{"title":"Using ignoreErrors​","type":1,"pageTitle":"Filtering","url":"/sentry-lua/docs/configuration/filtering#using-ignoreerrors","content":"You can use the ignoreErrors option to filter out errors that match a certain pattern. This option receives a list of strings and regular expressions to match against the error message. Sentry.init({ dsn = &quot;__DSN__&quot;, ignoreErrors = { &quot;fb_xd_fragment&quot;, RegExp([[^Exact Match Message$]]) }, })  "},{"title":"Filtering Transaction Events​","type":1,"pageTitle":"Filtering","url":"/sentry-lua/docs/configuration/filtering#filtering-transaction-events","content":"To prevent certain transactions from being reported to Sentry, use the tracesSampler or beforeSendTransactionconfiguration option, which allows you to provide a function to evaluate the current transaction and drop it if it's not one you want. "},{"title":"Using tracesSampler​","type":1,"pageTitle":"Filtering","url":"/sentry-lua/docs/configuration/filtering#using-tracessampler","content":"Note: The tracesSampler and tracesSampleRate config options are mutually exclusive. If you define atracesSampler to filter out certain transactions, you must also handle the case of non-filtered transactions by returning the rate at which you'd like them sampled. In its simplest form, used just for filtering the transaction, it looks like this: Sentry.init({ -- ... tracesSampler = function(samplingContext) if &quot;...&quot; then -- Drop this transaction, by setting its sample rate to 0% return 0 else -- Default sample rate for all others (replaces tracesSampleRate) return 1 end end, })  It also allows you to sample different transactions at different rates. If the transaction currently being processed has a parent transaction (from an upstream service calling this service), the parent (upstream) sampling decision will always be included in the sampling context data, so that yourtracesSampler can choose whether and when to inherit that decision. In most cases, inheritance is the right choice, to avoid breaking distributed traces. A broken trace will not include all your services. SeeInheriting the parent sampling decision to learn more. Learn more about configuring the sample rate. "},{"title":"Using beforeSendTransaction​","type":1,"pageTitle":"Filtering","url":"/sentry-lua/docs/configuration/filtering#using-beforesendtransaction","content":"Sentry.init({ dsn = &quot;__DSN__&quot;, -- Called for transaction events beforeSendTransaction = function(event) -- Modify or drop the event here if event.transaction == &quot;/unimportant/route&quot; then -- Don't send the event to Sentry return nil end return event end, })  "},{"title":"Using ignoreTransactions​","type":1,"pageTitle":"Filtering","url":"/sentry-lua/docs/configuration/filtering#using-ignoretransactions","content":"You can use the ignoreTransactions option to filter out transactions that match a certain pattern. This option receives a list of strings and regular expressions to match against the transaction name. Sentry.init({ dsn = &quot;__DSN__&quot;, ignoreTransactions = { &quot;partial/match&quot;, RegExp([[^Exact Match Message$]]) }, })  "},{"title":"Source Maps","type":0,"sectionRef":"#","url":"/sentry-lua/docs/sourcemaps/","content":"","keywords":""},{"title":"Sourcemap Setup​","type":1,"pageTitle":"Source Maps","url":"/sentry-lua/docs/sourcemaps/#sourcemap-setup","content":"Sourcemaps must be manually built with the Rojo CLI, and then included in your relevant *.project.json file. To generate a sourcemap file, run the following command (replacing default.project.json as required): rojo sourcemap default.project.json --output sourcemap.json  Once you've built a sourcemap, you should include it in your Rojo project. For example: { &quot;name&quot;: &quot;project-name&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;ReplicatedStorage&quot;: { &quot;Sourcemap&quot;: { &quot;$path&quot;: &quot;sourcemap.json&quot; } }, } }  Note that there are a few gotchas with this approach, so please refer to theTroubleshooting Guide if you run into any problems. "},{"title":"Configuration​","type":1,"pageTitle":"Source Maps","url":"/sentry-lua/docs/sourcemaps/#configuration","content":"Once you have a sourcemap included in your project, you need to add it to the Sentry configuration. Rojo converts jsonfiles to standard tables in a ModuleScript, so you can import your sourcemap like you would any other module. local Sourcemap = require(Path.To.Sourcemap) Sentry.init({ dsn = &quot;__DSN__&quot;, -- Depending on your Luau configuration, your imported Sourcemap file may -- not be given the correct type statically. Unfortunately, the only way -- to get around this is casting to `any`. projectSourcemap = Sourcemap :: any, })  Once configured, your errors should start sending with filesystem paths:  "},{"title":"Usage","type":0,"sectionRef":"#","url":"/sentry-lua/docs/usage/","content":"","keywords":""},{"title":"Capturing Errors​","type":1,"pageTitle":"Usage","url":"/sentry-lua/docs/usage/#capturing-errors","content":"You can pass an Error object to captureException() to get it captured as event. It's also possible to pass non-Error objects and strings, but be aware that the resulting events in Sentry may be missing a stacktrace and other metadata. If you are using Roblox, the LuauPolyfill library exposes a JavaScript Error object which this SDK is designed to work with. local Sentry = require(Path.To.Sentry) local success, result = pcall(function() return aFunctionThatMightFail() end) if not success then Sentry.captureException(result) end  "},{"title":"Capturing Messages​","type":1,"pageTitle":"Usage","url":"/sentry-lua/docs/usage/#capturing-messages","content":"Another common operation is to capture a bare message. A message is textual information that should be sent to Sentry. Typically, the SDKs don't automatically capture messages, but you can capture them manually. Sentry.captureMessage(&quot;Something went wrong&quot;)  "},{"title":"Sampling","type":0,"sectionRef":"#","url":"/sentry-lua/docs/configuration/sampling","content":"","keywords":""},{"title":"Sampling Error Events​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#sampling-error-events","content":"To send a representative sample of your errors to Sentry, set the sampleRate option in your SDK configuration to a number between 0 (0% of errors sent) and 1 (100% of errors sent). This is a static rate, which will apply equally to all errors. For example, to sample 25% of your errors: Sentry.init({ sampleRate = 0.25 })  Changing the error sample rate requires re-deployment. In addition, setting an SDK sample rate limits visibility into the source of events. Setting a rate limit for your project (which only drops events when volume is high) may better suit your needs. "},{"title":"Sampling Transaction Events​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#sampling-transaction-events","content":"Sentry recommends sampling your transactions for two reasons: Capturing a single trace involves minimal overhead, but capturing traces for every page load or every API request may add an undesirable load to your system.Enabling sampling allows you to better manage the number of events sent to Sentry, so you can tailor your volume to your organization's needs. Choose a sampling rate with the goal of finding a balance between performance and volume concerns with data accuracy. You don't want to collect too much data, but you want to collect sufficient data from which to draw meaningful conclusions. If you’re not sure what rate to choose, start with a low value and gradually increase it as you learn more about your traffic patterns and volume. "},{"title":"Configuring the Transaction Sample Rate​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#configuring-the-transaction-sample-rate","content":"The Sentry SDKs have two configuration options to control the volume of transactions sent to Sentry, allowing you to take a representative sample: Uniform sample rate (tracesSampleRate): Provides an even cross-section of transactions, no matter where in your app or under what circumstances they occur.Uses default inheritance and precedence behavior Sampling function (tracesSampler) which: Samples different transactions at different ratesFilters out some transactions entirelyModifies default inheritance and precedence behavior "},{"title":"Setting a Uniform Sample Rate​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#setting-a-uniform-sample-rate","content":"To do this, set the tracesSampleRate option in your Sentry.init() to a number between 0 and 1. With this option set, every transaction created will have that percentage chance of being sent to Sentry. (So, for example, if you settracesSampleRate to 0.5, approximately 50% of your transactions will get recorded and sent.) That looks like this: Sentry.init({ -- ... tracesSampleRate = 0.5, })  "},{"title":"Setting a Sampling Function​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#setting-a-sampling-function","content":"To use the sampling function, set the tracesSampler option in your Sentry.init() to a function that will accept asamplingContext object and return a sample rate between 0 and 1. For example: Sentry.init({ -- ... tracesSampler = function(samplingContext) -- Examine provided context data (including parent decision, if any) along -- with anything in the global namespace to compute the sample rate or -- sampling decision for this transaction if &quot;...&quot; then -- These are important - take a big sample return 1 elseif &quot;...&quot; then -- These are less important or happen much more frequently - only take 1% return 0.01 elseif &quot;...&quot; then -- These aren't something worth tracking - drop all transactions like this return 0 else -- Default sample rate return 0.5 end end, })  For convenience, the function can also return a boolean. Returning true is equivalent to returning 1, and will guarantee the transaction will be sent to Sentry. Returning false is equivalent to returning 0 and will guarantee the transaction will not be sent to Sentry. "},{"title":"Sampling Context Data​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#sampling-context-data","content":""},{"title":"Default Sampling Context Data​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#default-sampling-context-data","content":"The information contained in the samplingContext object passed to the tracesSampler when a transaction is created varies by platform and integration. For Roblox-based SDKs, it includes at least the following: -- contents of `samplingContext` { transactionContext = { name = string, -- human-readable identifier, like &quot;GET /users&quot; op = string, -- short description of transaction type, like &quot;pageload&quot; }, parentSampled = boolean, -- if this transaction has a parent, its sampling decision ... -- custom context as passed to `startTransaction` }  "},{"title":"Custom Sampling Context Data​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#custom-sampling-context-data","content":"When using custom instrumentation to create a transaction, you can add data to the samplingContext by passing it as an optional second argument to startTransaction. This is useful if there's data to which you want the sampler to have access but which you don't want to attach to the transaction as tags or data, such as information that's sensitive or that’s too large to send with the transaction. For example: Sentry.startTransaction( { -- `transactionContext` - will be recorded on transaction name = &quot;Search from navbar&quot;, op = &quot;search&quot;, tags = { testGroup = &quot;A3&quot;, treatmentName = &quot;eager load&quot;, }, }, -- `customSamplingContext` - won't be recorded { -- PII userId = &quot;12312012&quot;, -- too big to send resultsFromLastSearch = { ... }, } )  "},{"title":"Inheritance​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#inheritance","content":"Whatever a transaction's sampling decision, that decision will be passed to its child spans and from there to any transactions they subsequently cause in other services. (See Distributed Tracing for more about how that propagation is done.) If the transaction currently being created is one of those subsequent transactions (in other words, if it has a parent transaction), the upstream (parent) sampling decision will be included in the sampling context data. YourtracesSampler can use this information to choose whether to inherit that decision. In most cases, inheritance is the right choice, to avoid breaking distributed traces. A broken trace will not include all your services. In some SDKs, for convenience, the tracesSampler function can return a boolean, so that a parent's decision can be returned directly if that's the desired behavior. tracesSampler = function(samplingContext) -- always inherit if samplingContext.parentSampled ~= nil then return samplingContext.parentSampled end ... -- rest of sampling logic here end  If you're using a tracesSampleRate rather than a tracesSampler, the decision will always be inherited. "},{"title":"Forcing a Sampling Decision​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#forcing-a-sampling-decision","content":"If you know at transaction creation time whether or not you want the transaction sent to Sentry, you also have the option of passing a sampling decision directly to the transaction constructor (note, not in the customSamplingContextobject). If you do that, the transaction won't be subject to the tracesSampleRate, nor will tracesSampler be run, so you can count on the decision that's passed not to be overwritten. Sentry.startTransaction({ name = &quot;Search from navbar&quot;, sampled = true, })  "},{"title":"Precedence​","type":1,"pageTitle":"Sampling","url":"/sentry-lua/docs/configuration/sampling#precedence","content":"There are multiple ways for a transaction to end up with a sampling decision. Random sampling according to a static sample rate set in tracesSampleRateRandom sampling according to a sample function rate returned by tracesSamplerAbsolute decision (100% chance or 0% chance) returned by tracesSamplerIf the transaction has a parent, inheriting its parent's sampling decisionAbsolute decision passed to startTransaction When there's the potential for more than one of these to come into play, the following precedence rules apply: If a sampling decision is passed to startTransaction, that decision will be used, overriding everything else.If tracesSampler is defined, its decision will be used. It can choose to keep or ignore any parent sampling decision, use the sampling context data to make its own decision, or choose a sample rate for the transaction. We advise against overriding the parent sampling decision because it will break distributed traces)If tracesSampler is not defined, but there's a parent sampling decision, the parent sampling decision will be used.If tracesSampler is not defined and there's no parent sampling decision, tracesSampleRate will be used. "},{"title":"Sentry Roblox","type":0,"sectionRef":"#","url":"/sentry-lua/docs/intro","content":"","keywords":""},{"title":"Install​","type":1,"pageTitle":"Sentry Roblox","url":"/sentry-lua/docs/intro#install","content":"To get started using the Sentry Roblox SDK, you need to install it. This can be done in several ways, but we recommendWally: # wally.toml [dependencies] Sentry = &quot;neura-studios/sentry-roblox@1.0.0&quot;  wally install  "},{"title":"Configure​","type":1,"pageTitle":"Sentry Roblox","url":"/sentry-lua/docs/intro#configure","content":"Configuration should happen as early as possible in your games's lifecycle. Once this is done, the Roblox SDK captures all unhandled exceptions and transactions based on the sample rates set. local Sentry = require(Path.To.Sentry) local Sourcemap = require(Path.To.Sourcemap) Sentry.init({ dsn = &quot;__DSN__&quot;, release = &quot;my-game-name@2.3.12&quot;, integrations = {}, -- Include stacktraces in error events. attachStacktrace = true, -- If you project is managed by Rojo, you can include -- a sourcemap for converting datamodel paths back to -- their original path on the file system. projectSourcemap = Sourcemap, })  "},{"title":"Verify​","type":1,"pageTitle":"Sentry Roblox","url":"/sentry-lua/docs/intro#verify","content":"This snippet includes an intentional error, so you can test that everything is working as soon as you set it up. myUndefinedFunction()  Errors triggered from within the Studio command bar are sandboxed, so will not trigger an error handler. Place the snippet directly in your code instead. Learn more about manually capturing an error or message in the Usage documentation. To view and resolve the recorded error, log into sentry.io and open your project. Clicking on the error's title will open a page where you can see detailed information and mark it as resolved. "},{"title":"Next Steps​","type":1,"pageTitle":"Sentry Roblox","url":"/sentry-lua/docs/intro#next-steps","content":"Installation MethodsReview our alternate installation methods.ConfigurationAdditional configuration options for the SDK.UsageUse the SDK to manually capture errors and other events.Source MapsLearn how to enable more usable stack traces in your Sentry errors.Data ManagementManage your events by pre-filtering, scrubbing sensitive information, and forwarding them to other systems. "},{"title":"Set the Level","type":0,"sectionRef":"#","url":"/sentry-lua/docs/usage/set-level","content":"Set the Level The level - similar to logging levels - is generally added by default based on the integration. You can also override it within an event. To set the level out of scope, you can call captureMessage() per event: Sentry.captureMessage(&quot;this is a debug message&quot;, &quot;debug&quot;) Available levels are &quot;fatal&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;log&quot;, &quot;info&quot;, and &quot;debug&quot; To set the level within scope, you can call setLevel(): Sentry.configureScope(function(scope) scope:setLevel(&quot;warning&quot;) end) or per event: Sentry.withScope(function(scope) scope:setLevel(&quot;info&quot;) -- The exception has the event level set by the scope (info). Sentry.captureException(Error.new(&quot;custom error&quot;)) end) -- Outside of withScope, the Event level will have their previous value restored. -- The exception has the event level set (error). Sentry.captureException(Error.new(&quot;custom error 2&quot;)) ","keywords":""},{"title":"SDK Fingerprinting","type":0,"sectionRef":"#","url":"/sentry-lua/docs/usage/sdk-fingerprinting","content":"","keywords":""},{"title":"Basic Example​","type":1,"pageTitle":"SDK Fingerprinting","url":"/sentry-lua/docs/usage/sdk-fingerprinting#basic-example","content":"In the most basic case, values are passed directly: local function makeRequest(method, path, options) return fetch(method, path, options):catch(function(err) Sentry.withScope(function (scope) -- group errors together based on their request and response scope:setFingerprint({method, path, tostring(err.statusCode)}) Sentry.captureException(err) end) end) end  You can use variable substitution to fill dynamic values into the fingerprint generally computed on the server. For instance, the value {{ default }} can be added to add the entire normally generated grouping hash into the fingerprint. These values are the same as for server-side fingerprinting. SeeVariables for more information. "},{"title":"Group Errors With Greater Granularity​","type":1,"pageTitle":"SDK Fingerprinting","url":"/sentry-lua/docs/usage/sdk-fingerprinting#group-errors-with-greater-granularity","content":"In some scenarios, you'll want to group errors more granularly. For example, if your application queries a Remote Procedure Call Model (RPC) interface or external Application Programming Interface (API) service, the stack trace is generally the same, even if the outgoing request is very different. The following example will split up the default group Sentry would create (represented by {{ default }}) further, taking some attributes on the error object into account: local LuauPolyfill = require(Path.To.LuauPolyfill) local Error = LuauPolyfill.Error local extend = LuauPolyfill.extend local instanceof = LuauPolyfill.instanceof local MyRPCError = extends(Error, &quot;MyRPCError&quot;, function(self, message, functionName, errorCode) self.name = &quot;MyRPCError&quot; self.message = message -- The name of the RPC function that was called (e.g. &quot;getAllBlogArticles&quot;) self.functionName = functionName -- For example a HTTP status code returned by the server. self.errorCode = errorCode end) Sentry.init({ -- ... beforeSend = function(event, hint) local exception = hint.originalException if exception and instanceof(exception, MyRPCError) then event.fingerprint = { &quot;{{ default }}&quot;, tostring(exception.functionName), tostring(exception.errorCode), } end return event end, })  "},{"title":"Group Errors More Aggressively​","type":1,"pageTitle":"SDK Fingerprinting","url":"/sentry-lua/docs/usage/sdk-fingerprinting#group-errors-more-aggressively","content":"You can also overwrite Sentry's grouping entirely. For example, if a generic error, such as a database connection error, has many different stack traces and never groups them together, you can overwrite Sentry's grouping by omitting {{ default }} from the array: local DatabaseConnectionError = extends(Error, &quot;DatabaseConnectionError&quot;, function(self, message) self.name = &quot;DatabaseConnectionError&quot; self.message = message end) Sentry.init({ -- ... beforeSend = function(event, hint) local exception = hint.originalException if exception and instanceof(exception, DatabaseConnectionError) then event.fingerprint = { &quot;database-connection-error&quot; } end return event end, })  "}]